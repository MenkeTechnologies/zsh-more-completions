#compdef spindump

local arguments

arguments=(
  '-i[read in the file at <path> and generate a spindump report.]'
  '-o[specifies where to write results. If <path> is a directory]'
  '-startTime[omit samples before the given wall time specified as a string]'
  '-endTime[omit samples after the given wall time specified as a string]'
  '-startMachTimeNs[omit samples before the given mach time (in nanoseconds)]'
  '-endMachTimeNs[omit samples after the given mach time (in nanoseconds)]'
  '-machTimeRangeNs[only include samples in the given mach time range (nanoseconds)]'
  '-indexRange[only include samples in the given range]'
  '-startIndex[omit samples before sample number <int>]'
  '-endIndex[omit samples after sample number <int>]'
  '-heavy[sort stacks by count (default)]'
  '-timeline[sort stacks chronologically]'
  '-noText[omit textual format (include binary format only)]'
  '-noBinary[omit binary format (include text format only)]'
  '-noFile[do not output to a file (the report, including binary format]'
  '-stdout[print the report to stdout]'
  '-json[print the report in json format]'
  '-siginfo[after sampling, wait for SIGINFO before reporting]'
  '-timelimit[exit after t seconds even if the report hasnt been saved]'
  '-open[specifies an app in which to open the resulting report]'
  '-reveal[reveal the resulting report in Finder]'
  '-delayonsignal[stop sampling t seconds after receiving a signal]'
  '-wait[wait for the process to exist before sampling. If the]'
  '-displayIdleWorkQueueThreads[display idle work queue threads]'
  '-verbose[verbose report output]'
  '-nothrottle[do not throttle sampling rate on excessive memory growth]'
  '-noProcessingWhileSampling[do not parse stackshots until done sampling]'
  '-inspectLiveSystem[when parsing an input file, assume the data was gathered]'
  '-dscSymDir[the path to dscsym directory containing shared cache]'
  '-dsym[path to a dsym to use during symbolication (may be specified]'
  '-dsymForUUID[dsymForUUID to find symbols for everything (takes a while).]'
  '-findDsyms[/partial name> Use dsymForUUID to find symbols for frames]'
  '-onlyRunnable[include stacks of runnable threads]'
  '-onlyBlocked[only include stacks of blocked threads]'
  '-sampleWithoutTarget[for entire duration even if target exits]'
  '-onlyTarget[only sample the target process (allows faster sampling]'
  '-proc[/partial name>]'
  '-symbolicate[) Symbolicate the report]'
  '-noSymbolicate[not symbolicate the report. UUID+offset information will]'
  '-bootProfile[boot profile stackshots rather than sample live]'
  '-aggregateStacksByThread[stacks by thread ID rather than dispatch queue]'
  '-aggregateStacksByProcess[process gets one stack for all threads]'
  '-wake[monitor when the machine wakes and save a report.]'
  '-microstackshots[report interrupt microstackshots.]'
  '-microstackshots[_io]'
  '-microstackshots[_datastore <path>]'
  '-microstackshots[_save]'
  '-microstackshots[_starttime <date>]'
  '-microstackshots[_endtime <date>]'
  '-microstackshots[_pid <pid>]'
  '-microstackshots[_threadid <thread_id>]'
  '-microstackshots[_dsc_path <path>]'
  '-threadpriority[_min <int>]'
  '-threadpriority[_max <int>]'
  '-batteryonly[filter out any stacks from when the machine was on AC]'
  '-aconly[filter out any stacks from when the machine was on battery]'
  '-useridleonly[filter out any stacks from when the user was active]'
  '-useractiveonly[filter out any stacks from when the user was idle]'
  '*:filename:_files'
)

_arguments -s $arguments
