#compdef ddrescue

local arguments

arguments=(
  '(- * :)'{-h,--help}'[display this help and exit]'
  {-V,--version}'[output version information and exit]'
  {-a,--min-read-rate}'[minimum read rate of good areas in bytes/s]'
  {-A,--try-again}'[mark non-trimmed, non-scraped as non-tried]'
  {-b,--sector-size}'[sector size of input device \[default 512\]]'
  {-B,--binary-prefixes}'[show binary multipliers in numbers \[SI\]]'
  {-c,--cluster-size}'[sectors to copy at a time \[128\]]'
  {-C,--complete-only}'[dont read new data beyond mapfile limits]'
  {-d,--idirect}'[use direct disc access for input file]'
  {-D,--odirect}'[use direct disc access for output file]'
  {-e,--max-bad-areas}'[+\]<n> maximum number of \[new\] bad areas allowed]'
  {-E,--max-error-rate}'[maximum allowed rate of read errors per second]'
  {-f,--force}'[overwrite output device or partition]'
  {-F,--fill-mode}'[fill blocks of given types with data (?*/-+l)]'
  {-G,--generate-mode}'[generate approximate mapfile from partial copy]'
  {-H,--test-mode}'[set map of good/bad blocks from given mapfile]'
  {-i,--input-position}'[starting position of domain in input file \[0\]]'
  {-I,--verify-input-size}'[verify input file size with size in mapfile]'
  {-J,--verify-on-error}'[reread latest good sector after every error]'
  {-K,--skip-size}'[<max>\] initial,maximum size to skip on read error]'
  {-L,--loose-domain}'[accept an incomplete domain mapfile]'
  {-m,--domain-mapfile}'[restrict domain to finished blocks in <file>]'
  {-M,--retrim}'[mark all failed blocks as non-trimmed]'
  {-n,--no-scrape}'[skip the scraping phase]'
  {-N,--no-trim}'[skip the trimming phase]'
  {-o,--output-position}'[starting position in output file \[ipos\]]'
  {-O,--reopen-on-error}'[reopen input file after every read error]'
  {-p,--preallocate}'[preallocate space on disc for output file]'
  {-P,--data-preview}'[show some lines of the latest data read \[3\]]'
  {-q,--quiet}'[suppress all messages]'
  {-r,--retry-passes}'[exit after <n> retry passes (-1=infinity) \[0\]]'
  {-R,--reverse}'[reverse the direction of all passes]'
  {-s,--size}'[maximum size of input data to be copied]'
  {-S,--sparse}'[use sparse writes for output file]'
  {-t,--truncate}'[truncate output file to zero size]'
  {-T,--timeout}'[maximum time since last successful read]'
  {-u,--unidirectional}'[run all passes in the same direction]'
  {-v,--verbose}'[be verbose (a 2nd -v gives more)]'
  {-w,--ignore-write-errors}'[make fill mode ignore write errors]'
  {-x,--extend-outfile}'[extend outfile size to be at least this long]'
  {-X,--max-read-errors}'[maximum number of read errors allowed]'
  {-y,--synchronous}'[use synchronous writes for output file]'
  {-Z,--max-read-rate}'[maximum read rate in bytes/s]'
  '--ask[ask for confirmation before starting the copy]'
  '--cpass[<n>\] select what copying pass(es) to run]'
  '--delay-slow[initial delay before checking slow reads \[30\]]'
  '--log-events[log significant events in <file>]'
  '--log-rates[log rates and error sizes in <file>]'
  '--log-reads[log all read operations in <file>]'
  '--mapfile-interval[i\] save/sync mapfile at given interval \[auto\]]'
  '--max-slow-reads[maximum number of slow reads allowed]'
  '--pause-on-error[time to wait after each read error \[0\]]'
  '--pause-on-pass[time to wait between passes \[0\]]'
  '--reset-slow[reset slow reads if rate rises above min]'
  '*:filename:_files'
)

_arguments -s $arguments
